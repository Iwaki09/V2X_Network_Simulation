# V2X_Network_Simulation

## 研究テーマ概要

### **研究テーマ**
V2X通信環境における物理伝搬シミュレーションを統合したネットワークのグローバル最適化手法

### **背景と課題**
自動運転の実現に不可欠なV2X（Vehicle-to-Everything）通信では、車両の移動や周辺車両、建物などによる電波の遮蔽（ブロッケージ）が頻繁に発生し、通信品質が動的に大きく変動する。

従来のネットワーク制御手法の多くは、各車両が自身の通信品質のみに基づいて接続先基地局などを選択する**分散型（distributed）**かつ**リアクティブ（事後的）**なアプローチが主流であった。このアプローチでは、特定の基地局に接続が集中してリソースが枯渇するなど、ネットワーク全体で見た非効率性（**局所最適化**）という課題があった。

### **研究目的**
本研究の目的は、高精度な物理伝搬シミュレーションから得られるリアルタイムのリンク品質情報を活用し、ネットワーク全体のパフォーマンス（総スループット、公平性、遅延など）を最大化する**集中制御型（centralized）**の**グローバル最適化手法**を提案し、その有効性を検証することである。

### **提案手法の概要**
提案手法は、MEC（Multi-access Edge Computing）サーバーのような中央コントローラーが以下のステップでネットワーク全体の最適化を行う。

1.  **ネットワーク状態の統合監視**:
    * 交通流シミュレーターから全車両の位置・速度・移動予測データを収集する。
    * 物理伝搬シミュレーターを用いて、全車両と全基地局間の通信リンク品質（データレート、遅延、パケットロス率など）をリアルタイムに算出する。

2.  **動的グラフによる状態表現**:
    * 監視したネットワークの状態を**動的なグラフ**として表現する。ここで、ノードは車両や基地局、エッジ（辺）はそれらの間の通信リンク、エッジの重みはリンク品質を表す。

3.  **グローバル最適化アルゴリズムの実行**:
    * 中央コントローラーは、生成された動的グラフに基づき、ネットワーク全体の性能指標を最大化する最適化問題を解く。この中核アルゴリズムとして、以下のいずれかの手法を検討する。
        * **A) 数理最適化**: ネットワーク規模が小さい場合に、厳密な最適解を求める。
        * **B) グラフニューラルネットワーク（GNN）**: グラフ構造を直接学習可能なGNNを用い、大規模なネットワークにおいても高速かつ高精度に準最適な構成（どの車両がどの基地局に接続すべきか等）を推定するモデルを構築する。

4.  **ネットワーク制御の適用**:
    * 最適化計算によって得られた接続プランやリソース割り当て計画を、各車両および基地局に指示し、ネットワーク構成を更新する。

### **シミュレーション環境**
本研究の有効性を実証するため、以下のシミュレーターを連携させた統合環境を構築する。

* **交通流シミュレーター**: `SUMO` または `CARLA`
* **物理伝搬シミュレーター**: `VAN3TWin` + `SIONNA RT`
* **ネットワークシミュレーター**: `NS-3`

### **期待される効果と新規性**
* **期待される効果**: 従来の分散型手法と比較して、ネットワーク全体の総スループット向上、通信の安定化、リソース利用効率の大幅な改善が期待される。
* **新規性**:
    1.  **高精度な物理モデルの統合**: 理想化されたモデルではなく、レイトレーシングに基づく現実的な物理伝搬シミュレーションの結果を直接ネットワーク最適化問題の入力として利用する点。
    2.  **グローバルな視点での最適化**: 個々の車両の利益（局所最適）ではなく、システム全体の利益（大域的最適）を追求する集中制御型の枠組みをV2Xの動的環境に適用する点。
    3.  **先進的な最適化手法の応用**: 特に、動的なグラフ構造を持つV2Xネットワークの最適化問題に対し、**グラフニューラルネットワーク（GNN）**のような最先端のAI技術を適用する点に高い独創性がある。

## 動的シミュレーションの実装 (`prototype2`)

本研究のステップ1「ネットワーク状態の統合監視」の基盤として、車両の移動に伴う通信品質の変動をシミュレートする環境を構築した。

### ディレクトリ構造

```
prototype2/
├── output/                # シミュレーション結果の出力先
│   ├── scenario1/         # 生成されたシナリオのシーンファイル
│   └── simulation_results.json # 動的シミュレーションの結果
├── src/                   # ソースコード
│   ├── scene_parser.py      # scene.json の読み込み
│   ├── mitsuba_converter.py # Mitsuba 3 形式への変換
│   └── run_raytracing.py    # Sionna RT を使ったレイトレーシング実行
├── main.py                # 動的シミュレーション実行スクリプト
├── scenario_generator.py    # 車両移動シナリオ生成スクリプト
└── scene.json             # シミュレーションのベースとなる静的シーン定義
```

### 実行方法

1.  **車両移動シナリオの生成**

    以下のコマンドを実行すると、`prototype2/scene.json` をベースに、車両が移動する10タイムステップ分のシーンファイル (`scene_t0.json` ~ `scene_t9.json`) が `prototype2/output/scenario1/` ディレクトリに生成される。

    ```bash
    python3 prototype2/scenario_generator.py
    ```

2.  **動的シミュレーションの実行**

    以下のコマンドを実行すると、生成されたシナリオファイルを順番に読み込み、各タイムステップでのレイトレーシングによるパスロス計算が実行される。

    ```bash
    python3 prototype2/main.py
    ```

### 出力結果

シミュレーションが完了すると、全タイムステップのパスロス行列を記録した `prototype2/output/simulation_results.json` が生成される。

```json
[
    {
        "timestamp": "scene_t0.json",
        "path_loss_matrix": [
            [83.947649, 83.93088341],
            [77.62229443, 84.14402008]
        ]
    },
    {
        "timestamp": "scene_t1.json",
        "path_loss_matrix": [
            [...]
        ]
    },
    ...
]
```

さらに、`simulation_results.json` と `prototype2/scene.json` を基に、各タイムステップのネットワーク状態をグラフ構造で表現した `prototype2/output/graph_data.json` が生成される。

```json
[
    {
        "timestamp": "scene_t0.json",
        "nodes": [
            {"id": "vehicle1", "type": "vehicle"},
            {"id": "vehicle2", "type": "vehicle"},
            {"id": "bs1", "type": "base_station"},
            {"id": "bs2", "type": "base_station"}
        ],
        "edges": [
            {"source": "vehicle1", "target": "bs1", "weight": 83.947649},
            {"source": "vehicle1", "target": "bs2", "weight": 83.93088341},
            {"source": "vehicle2", "target": "bs1", "weight": 77.62229443},
            {"source": "vehicle2", "target": "bs2", "weight": 84.14402008}
        ]
    },
    ...
]
```
